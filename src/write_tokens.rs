use std::{
    io::{self, Write},
    process::Child,
};

use proc_macro2::TokenStream;
use quote::quote;

/// Write tokens to some output, blocking until completion.
pub fn write_tokens_blocking<W: Into<std::process::Stdio>>(
    tokens: TokenStream,
    out: W,
) -> io::Result<()> {
    let mut child = write_tokens(tokens, out)?;

    let status = child.wait()?;

    if !status.success() {
        return Err(io::Error::other(format!("Exit code {status}")));
    }

    Ok(())
}

/// Write a set of tokens to their own outputs in parallel. Blocks until they are all completed.
pub fn write_tokens_parallel<W: Into<std::process::Stdio>>(
    tokens: Vec<(TokenStream, W)>,
) -> Result<(), Vec<(usize, io::Error)>> {
    let mut errors = vec![];

    let children: Vec<_> = tokens
        .into_iter()
        .map(|(tokens, out)| write_tokens(tokens, out))
        .collect();

    for (index, child) in children.into_iter().enumerate() {
        match child {
            Ok(mut child) => match child.wait() {
                Ok(status) => {
                    if !status.success() {
                        errors.push((index, io::Error::other(format!("Exit code {status}"))));
                    }
                }
                Err(error) => errors.push((index, error)),
            },
            Err(error) => errors.push((index, error)),
        }
    }

    if errors.is_empty() {
        Ok(())
    } else {
        Err(errors)
    }
}

/// Writes a token to some output, returning the `rustfmt` process responsible for writing and formatting.
pub fn write_tokens<W: Into<std::process::Stdio>>(
    tokens: TokenStream,
    out: W,
) -> io::Result<Child> {
    let doc_string = format!(
        "Generated by {} v{}",
        env!("CARGO_PKG_NAME"),
        env!("CARGO_PKG_VERSION")
    );

    let mut output_tokens = quote! {
        #![doc = #doc_string]
        #![allow(unused, missing_docs)]
    };
    output_tokens.extend(tokens);

    let mut child = std::process::Command::new("rustfmt")
        .arg("--edition")
        .arg("2024")
        .stdout(out)
        .stdin(std::process::Stdio::piped())
        .spawn()?;

    let mut stdin = child
        .stdin
        .take()
        .expect("Failed to take stdin on rustfmt process");

    stdin.write_all(output_tokens.to_string().as_bytes())?;

    Ok(child)
}
